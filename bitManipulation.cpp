#include<bits/stdc++.h>
using namespace std;

//Unless stated otherwise, assume space complexity is O(1) i.e, constant space
//Unless stated otherwise, assume time complexity is O(1) i.e, constant time



//Function to reverse a string
//Use two pointer method
void revString(string &str){
    int n=str.size();
    int i=0;
    int j=n-1;
    while(i<j){
        swap(str[i],str[j]);
        i++;
        j--;
    }
}
//Time complexity will be O(n) as each element is traversed once

//Converting a decimal to binary form
//We keep dividing by two taking down the remainder, then we reverse the string obtained
string decToBinary(int n){
    string str="";
    while(n>1){
        int rem=n%2;
        str=str+to_string(rem);
        n=n/2;
    }
    str+="1";
    revString(str);
    return str;
};
//Time Complexity will be O(log2 N) + O(n) (O(n) for rev string function and log2 N since inside while loop division by 2 occurs)


//Converting Binary Form to decimal
//Similar to dec to binary function
int binaryToDec(string str){
    int n=str.size();
    int j=0;
    int res=0;
    for(int i=n-1;i>=0;i--){
        int x=str[i]-'0';
        res=res+pow(2,j)*x;
        j++;
    }
    return res;
}
//Same Time complexity as for the previous function


//Some Basic Information about Bit Manipulation
/*
1s compliment : consider the number 13 has binary form=>1101 the ones compliment is generated by replacing 1 by 0 and vice versa
So its 1s compliment would be => 0010

2s compliment : first take out 1s compliment : consider 1101 ==> 0010(1s compliment) + 1(write as 0001) ==> 0011 this is the 2s compliment

And => both true->true otherwise false : eg=> 1101 & 0111 ==>0101
Or  => if both false=> false otherwise true : eg=>1101 or 0111 ==>1111
Xor => if no of 1s are even =>0 , if no of 1s are odd=>1 : for eg=> 1101 ^ 0111 =>1010

Right Shift >> eg : 13>>1 ==> right shift by one the binary number 1101 which will be 0110(remember shift, and not rotate)
Formulae for right shift x>>k == x/pow(2,k) (if it isn't an integer, just do the division as it happens in c++)

Before we discuss left shift we need to understand that a 32 bit computer system stores 32 bits so consider 13 which is 1101 , this has only 4 bits, so the rest 28 are stored as 0
so the number looks like : 000000...1101

Now the first bit in these 32 bits is used for storing sign, which is 0 for positive and 1 for negative
Suppose the computer has to store negative 13, it first stores 13 as binary which is 1101 , it then takes its 2s compliment which is 0010 , but it is actually 11111...0010 since 
the 1s in rest of the 28 bits also get changed then we add 1 to it which makes it 11111....0011, now this has a 1 at beginning which implies that this is a negative number

The INT_MAX value ??
Since the last place is reserved for storing sign, available spaces are 31 , storing the maximum means storing 1 in each. So the greatest number would be (2^0)*1 + (2^1)*1 + ....and 
so on, sum this up and we will get 2^(31-1) which is the value of INT_MAX;

The INT_MIN value ??
To store negative values, first take the positive value , convert it to binary form and then take its two's compliment
for eg : -2^(31)-1 , first take the binary form of 2^31-1 which is -> 011111111...1111 , now take its two's compliment -> 100000000...0000 + 1=>100000....00001 this is the value of INT_MIN


Left Shift << eg 13<<1 ==> 1101 left shift, remember 1101 is actually 0000000....1101 therefore the leftmost 0 is dropped and it becomes -> 0000...11010 (fill the empty place with 0)
Formula form left shift : x<<k => x*pow(2,k)

**If we try to take left shift of -2^31-1 we will get overflow , so remember these cases.

The Not operator (~)
Step1) take ones compliment. After that if the number is positive stop otherwise take two's compliment


Properties related to binary operations:
a^b=b^a
a|b=b|a
a&b=b&a
a&(b&c)=(a&b)&c
a^(b^c)=(a^b)^c
a&(b|c)=(a&b)|(a&c)
a&1=a
a|0=a
a^a=0
a^0=a
a&a=a
a|a=a
a&(a|b)=a
a|(a&b)=a
a&(~a)=0
a|(~a)=1

De Morgan's Laws
~(a&b)=(~a)|(~b)
~(a|b)=(~a)&(~b)

*/

//Swap Two Numbers without third variable
void swap(int a,int b){
    a=a^b;
    b=a^b;
    a=a^b;
}


//Check if the ith bit is set or not 
//1 is called set bit and 0 is called not set(since set means on and 1 represents on)
//Brute force will be using the convertToBinary function then checking for ith bit, remember the right most bit is the 0th bit (0 based indexing)
bool isIthBitSet_brute(int n,int i){
    string bin=decToBinary(n);
    int m=bin.size();
    if(i>m) return false;
    if(bin[m-i-1]=='1') return true;
    return false;
}

//Using the left shift operator
//Do calculation yourself for explanation
bool isIthBitSet_leftShift(int n,int i){
    bool ans=n&(1<<i);
    return ans;
}

//Using the right shift operator 
//Do calculation yourself for explanation
bool isIthBitSet_rightShift(int n,int i){
    bool ans=1&(n>>i);
    return ans;
}

//Making the ith bit 1, (self explanatory)
int setIthBit(int n,int i){
    int a=1<<i;
    int ans=a|n;
    return ans;
}

//Making the ith bit 0, (self explanatory)
int clearIthBit(int n,int i){
    int a=1<<i;
    a=~a;
    int ans=a&n;
    return ans;
}

//Toggling the ith bit, making it 0 if it is 1 and vice versa (self explanatory)
int toggleIthBit_brute(int n,int i){
    if(isIthBitSet_leftShift(n,i)==true) return clearIthBit(n,i);
    else return setIthBit(n,i);
}

//Self Explanatory
int toggleIthBit(int n,int i){
    int a=1<<i;
    int ans=a^n;
    return ans;
}

//Remove the last set bit(rightmost bit having)
//There's a trick to it, consider any number and its predecessor in binary form, do it 3 to 4 times, say for numbers (24,23) (40,39) (50,49) etc. 
//You will notice that the righmost bit is turned to 0 and all the other bits right to it are changed to 1 from 0
int clearRightMostSetBit(int n){
    int ans=n&(n-1);
    return ans;
}


//Set the rightmost unset bit
int setRightMostUnsetBit(int n){
    int ans=(n|(n+1));
    return ans;
}


//A number which is power of two has only one set bit in binary form, and that is also the rightmost bit so after we clear the rightmost bit, the number we get should be 0
bool isPowerOf2(int n){
    return !(n&(n-1));
}

//Using brute force
int countSetBits_brute(int n){
    int cnt=0;
    while(n>1){
        cnt+=n&1;//Since & operator with a odd number gives 1 and with a even number 0
        n=n>>1;
    }
    cnt++;
    return cnt;
}

//Most Experienced programmars use n&1 for odd/even check and n>>1 for dividing by 2
//For eg in binary search instead of writing (low+high)/2, write (low+high)>>1 as bitwise operations are much faster than anything else

//We can also use an inbuilt stl function
int countSetBits_usingSTL(int n){
    int ans=__builtin_popcount(n);
    return ans;
}

//Another approach would be using the clear righmost bit function logic repeatedly, since we keep clearing the rightmost bit , the number will eventually become 0
//we just keep a track of how many bits we have cleared
int countSetBits(int n){
    int cnt=0;
    while(n>0){
        n=n&(n-1);
        cnt++;
    }
    return cnt;
}

//Minimum bitFlips to convert a into b
//For this we need to find how many bits are different in both the binary forms
int minBitFlipsAToB_brute(int a,int b){
    string str1=decToBinary(a);
    string str2=decToBinary(b);
    int n=str1.size();
    int m=str1.size();
    if(n!=m) return -1;
    int cnt=0;
    for(int i=0;i<n;i++){
        if(str1[i]!=str2[i]) cnt++;
    }
    return cnt;
}
//Time complexity is O(n) + O(n) + O(n) ==> O(3N)
//Space Complexity will be total space used for storing str1 and str2 which will be O(log2 a) + O(log2 b)

//Xor method self explanatory
int minBitFlipsAToB(int a,int b){
    int x=a^b;
    //As doing xor of two numbers gives the number which has 1 on places with differing bits
    //Now we just count the number of set bits in x
    int ans=countSetBits(x);
    return ans;
}

//Printing all subsets
//See video for better explanation,only the bitwise solution
vector<vector<int>> allSubsets(vector<int> arr){
    vector<vector<int>> ans;
    int n=arr.size();
    //Finding the number of subsets : 2^n
    int t=(1<<n);
    for(int i=0;i<t;i++){
        vector<int> temp;
        for(int j=0;j<n;j++){
            if(i&(1<<j)) temp.push_back(arr[j]);
        }
        ans.push_back(temp);
    }
    return ans;
}
//Time complexity is : O(n*t)
//A temp array is used in solution


//Number appearing once where all others appears twice (already done in arr questions, brute method uses map hashing, optimal uses xor)

//Number appearing once where all others appears thrice 
//Again we can use the map hashing to find out, but the optimal approach uses bit manipulation techniques
int numAppearingOnceAmongTriplets_brute(vector<int> arr){
    unordered_map<int,int> mp;
    int n=arr.size();
    for(int i=0;i<n;i++){
        mp[arr[i]]++;
    }
    for(auto it:mp){
        if(it.second==1) return it.first;
    }
    return -1;
};
//Time complexity is O(2N)
//Space Complexity is O(N)

int numAppearingOnceAmongTriplets_better(vector<int> arr){
    int n=arr.size();
    int ans=0;
    int cnt;
    for(int bitIdx=0;bitIdx<32;bitIdx++){
        cnt=0;
        for(int i=0;i<n;i++){
            if(arr[i]&(1<<bitIdx)) cnt++;
        }
        if(cnt%3==1) ans=ans|(1<<bitIdx);
    }
    return ans;
} 
//Time complexity is O(32N)
//This still is not the best solution

int numAppearingOnceAmongTriplets_better2(vector<int> arr){
    int n=arr.size();
    sort(arr.begin(),arr.end());
    for(int i=1;i<n;i=i+3){
        if((arr[i]!=arr[i+1]) || (arr[i]!=arr[i-1])){
            return arr[i-1];
        }
    }
    return arr[n-1];
}
//Although the time complexity for this is N*LogN + N which seems to be greater than the previous solution which has TC of N*32 , but in most cases logN will be very small
//and will only be big when there are too many digits in binary(20 bits or more maybe) hence this solution is better

//Optimal solution requires the concept of buckets, need to watch video
int numAppearingOnceAmongTriplets_optimal(vector<int> arr){
    int n=arr.size();
    int ones=0;
    int twos=0;
    for(int i=0;i<n;i++){
        ones=(ones^arr[i])&(~twos);
        twos=(twos^arr[i])&(~ones);
    }
    return ones;
}
//Time Complexity will be O(N)


//Brute forceuses map
vector<int> numsAppearingOnceAmongDuplets_brute(vector<int> arr){
    int n=arr.size();
    unordered_map<int,int> mp;
    for(int i=0;i<n;i++){
        mp[arr[i]]++;
    }
    vector<int> ans;
    for(auto it:mp){
        if(it.second==1) ans.push_back(it.first);
    }
    if(ans[0]> ans[1]) swap(ans[0],ans[1]);
    return ans;
}
//Time Complexity will be O(2N)
//Space Complexity will be O(N)

//Watch video for explanation
vector<int> numsAppearingOnceAmongDuplets_optimal(vector<int> arr){
    int n=arr.size();
    int xr=0;
    for(int i=0;i<n;i++){
        xr=xr^arr[i];
    }
    int rightMost=((xr&(xr-1))&xr);
    int b1=0;
    int b2=0;
    for(int i=0;i<n;i++){
        if(arr[i]&rightMost) b1=b1^arr[i];
        else b2=b2^arr[i];
    }
    vector<int> ans={b1,b2};
    return ans;
}
//Time Complexity will be O(2N)


//Brute force 
int xorTillN_brute(int n){
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=ans^i;
    }
    return ans;
}

/*For optimal solution : remember that:
Xor of numbers from 1 to N is : 
1 if N%4==1
N+1 if N%4==1
0 if N%4==3
N if N%4==0;
*/


//Optimal approach, try finding xor from 1 to n (for different n , to get a hold of the pattern)
int xorTillN(int n){
    int ans=0;
    if(n%4==0) ans=n;
    else if(n%4==1) ans=1;
    else if(n%4==2) ans=n+1;
    else ans=0;

    return ans;
}


//Brute force self explanatory
int xorOfNumsInARange_brute(int l,int r){
    int ans=0;
    for(int i=l;i<=r;i++){
        ans=ans^i;
    }
    return ans;
}


//Find xor till r and xor it with xor till l-1
int xorOfNumsInARange_optimal(int l,int r){
    int ans=0;
    ans=xorTillN(r)^xorTillN(l-1);
    return ans;
}


//Divide 22 by 3 and give int ans without using the divisor of multiplication operator
//One method is keep on adding 3+3+3 and so on
//Count the number of threes added and eventually when the sum exceeds the dividend , you will get the quotient
int divideWithoutDivOrMultiplyOperators_brute(int dividend,int divisor){
    int x=divisor;
    int cnt=0;
    while(true){
        divisor=divisor+x;
        cnt++;
        if(divisor>dividend) break;
    }
    return cnt;
}


//Watch video for better explanation
//If one of the divisor or dividend is negative then we first calculate the ans with positive terms, then add negative sign at the end
int dividedWithoutDivOrMultiPlyOperators_optimal(int dividend,int divisor){
    if (dividend==divisor) return 1;
    bool sign=true;
    if((dividend>=0 && divisor<0) || (dividend<0 && divisor>0)) sign=false;
    int n=abs(dividend);
    int d=abs(divisor);
    int ans=0;
    while(n>=d){
        int cnt=0;
        while(n>=(d<<(cnt+1))){
            cnt++;
        }
        ans+=(1<<cnt);
        n=n-(d<<cnt);
    }
    if(ans>=(1<<31) && sign==true) return INT_MAX;
    if(ans>=(1<<31) && sign==false) return INT_MIN;

    return sign? ans:((-1)*ans);
}

//Time Complexity will be (log2 N)*(log2 N)
int main(){

    //Input function here
    return 0;
}
